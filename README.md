아래는 요청하신 리드미 형식에 기존 내용과 함께 토글로 이어 붙인 완성본입니다.

---

# shorten-url-service

단축 URL 서비스 레포지토리

### 요구사항

1. [bitly](https://bitly.com/) 같은 단축 URL 서비스를 만들어야 합니다.
2. 단축된 URL의 키(Key)는 8글자로 생성되어야 합니다. '단축된 URL의 키'는 '[https://bit.ly/3onGWgK](https://bit.ly/3onGWgK)' 에서 경로(Path)에 해당하는 '3onGWgK'를 의미합니다. bitly에서는 7글자의 키를 사용합니다.
3. 키 생성 알고리즘은 자유롭게 구현하시면 됩니다.
4. 단축된 URL로 사용자가 요청하면 원래의 URL로 리다이렉트(Redirect)되어야 합니다.
5. 원래의 URL로 다시 단축 URL을 생성해도 항상 새로운 단축 URL이 생성되어야 합니다. 이때 기존에 생성되었던 단축 URL도 여전히 동작해야 합니다.
6. 단축된 URL -> 원본 URL로 리다이렉트 될 때마다 카운트가 증가되어야하고, 해당 정보를 확인할 수 있는 API가 있어야합니다.
7. 데이터베이스 없이 컬렉션을 활용하여 데이터를 저장해야합니다.
8. 기능이 정상 동작하는 것을 확인할 수 있는 적절한 테스트 코드가 있어야 합니다.
9. (선택) 해당 서비스를 사용할 수 있는 UI 페이지를 구현해주세요.

### 필요 API

1. 단축 URL 생성 API
2. 단축 URL 리다이렉트 API
3. 단축 URL 정보 조회 API

<details>  
<summary>️ Spring Initializer 프로젝트 설정과 이유</summary>  

* **Spring Boot 3.x 기반 선택**

* Spring Boot 2는 곧 End of Life이 예정되어 있어, 장기적으로 유지보수가 불리하다.

* 스프링 생태계도 Spring Boot 3 중심으로 이동 중이므로, 학습 및 적용에 유리.

* **Java 17 사용**
  Java 17은 Long Term Support 버전으로, 안정성과 장기적인 유지보수가 보장된다.

* Spring Boot 3.x는 Java 17 이상을 요구하므로 호환성 측면에서 필수이기도함.

* **Gradle 사용**

* Gradle은 빌드 속도가 빠르고, 의존성 관리가 유연하며, 설정이 간결

* 최근 Spring 진영과 다양한 오픈소스 프로젝트에서도 **Gradle 사용 비율이 증가**하고 있어서 추세에 부합함

</details>  

<details>  
<summary>URL 경로의 네이밍</summary>  

대표적으로 카멜케이스 , Spinal 케이스, 스네이크 케이스 등이 있는데

* 카멜케이스 - 일관성 있지만, 알파벳 외엔 띄어쓰기가 어렵다
* spinal케이스 - 일반적으로 가장 권장되는 방식이다. 나는 학습을 위해 이 케이스를 선택!
* 스네이크케이스 - URL에서 제일 권장되지않는 형식이다. 가끔 언더바를 띄어쓰기가아닌 하나의 단어로 판단하는 경우가 있음.

</details>  

<details>  
<summary>URL 만들기</summary>  

단축 URL 서비스는 다음의 3가지 기능으로 구성된다. 각 기능에 맞는 RESTful API 경로는 다음과 같이 설계하였다.

---

### 1. 단축 URL 생성 API

* **Method**: POST
* **Endpoint**: `/shortenUrl`
* **설명**: 원본 URL을 입력받아 단축 URL을 생성하는 API이다.

#### 설계 고민

처음에는 다음과 같은 방식도 고려하였다:

```
GET /shortenUrl?originalUrl=https://www.example.com/page  
```

하지만 이 방식은 다음과 같은 문제점이 있다.

* **URL 인코딩 이슈**: 원본 URL이 길거나 복잡할 경우, 브라우저나 서버에서 쿼리 문자열 길이 제한에 걸릴 수 있다.
* **URL 노출 위험**: 로그, 히스토리, 브라우저 주소창 등을 통해 민감한 URL 정보가 쉽게 드러날 수 있다.
* **REST 원칙 위배**: `GET`은 안전하고 멱등한 방식으로 조회 용도에 적합하며, 새로운 리소스 생성을 위해서는 `POST`가 더 적절하다.

이러한 이유로 `POST /shortenUrl` 방식과, 본문(body)에 데이터를 담는 구조로 설계하였다.

**요청 예시**

```json
{  
  "originalUrl": "https://www.example.com/page"  
}  
```

**응답 예시**

```json
{  
  "shortUrl": "http://localhost:8080/AbCdEfGh"  
}  
```

---

### 2. 단축 URL 리다이렉트 API

* **Method**: GET
* **Endpoint**: `/{shortenUrlKey}`
* **설명**: 단축된 URL로 요청이 들어오면, 해당 키에 해당하는 원본 URL로 리다이렉트 시키는 API이다.

**예시 요청**

```
GET /AbCdEfGh  
```

> 서버는 302 Redirect 응답으로 원본 URL로 이동시킨다.

#### 설계 고민

단축 URL은 최종 사용자에게 노출되는 경로이므로 `/s/`나 `/shortenUrl/`과 같은 접두어 없이, 단순히 `/AbCdEfGh`와 같은 짧은 형식을 사용하는 것이 직관적이고 공유하기도 좋다.

---

### 3. 단축 URL 정보 조회 API

* **Method**: GET
* **Endpoint**: `/shortenUrl/{shortenUrlKey}`
* **설명**: 단축 URL에 대한 상세 정보(원본 URL, 리다이렉트 횟수 등)를 조회하는 API이다.

**응답 예시**

```json
{  
  "originalUrl": "https://www.example.com/page",  
  "redirectCount": 12,  
  "createdAt": "2025-07-09T13:00:00"  
}  
```

#### 설계 고민

해당 API는 생성된 단축 URL의 사용 통계를 확인하거나 추적하는 용도로 사용된다.
따라서 특정 리소스를 식별하는 형태인 `/shortenUrl/{shortenUrlKey}` 경로로 명확하게 표현했다.
데이터 조회이므로 `GET` 메서드가 적절하다.

</details>  

<details>  
<summary>단축 URL에서 허용하는 URL 타입</summary>  

* 단축 URL 서비스에서는 원본 URL이 반드시 `http://` 또는 `https://`로 시작해야 한다.
* 그 이유는 다음과 같다:

  1. **보안 및 명확성**: `http`/`https` 스킴이 없는 URL은 브라우저가 해석할 때 상대경로로 처리되거나, 비정상적인 동작을 할 수 있다.
  2. **리다이렉션 신뢰성**: 서버가 리다이렉트 시 명확한 프로토콜이 없는 URL은 정확한 원본 위치를 알 수 없다.
  3. **사용자 입력 오류 방지**: 프로토콜 없이 URL을 받으면 의도하지 않은 잘못된 주소로 연결될 가능성이 크다.
  4. **규칙 명확화**: 서비스 정책으로 명확히 제한하면 내부 로직 처리와 보안 검증이 쉬워진다.

</details>  


<details>  
<summary>나의 프로젝트 구조에서 DTO는 왜 Presentation 계층에 속하는가?</summary>  

  1. **DTO는 외부 요청/응답에 맞춘 데이터 형식이다**

    * 클라이언트(웹, 앱 등)와 통신하기 위한 데이터 전달용 객체로, 도메인의 핵심 비즈니스 모델과는 별도로 설계된다.
  2. **도메인과는 역할 분리가 명확해야 한다**

    * 도메인은 비즈니스 규칙과 상태를 관리하며, 내부 로직에 집중한다.
    * DTO가 도메인에 포함되면 도메인의 독립성이 훼손되고, 외부 변경에 도메인이 직접 영향을 받는다.

</details>


<details>  
<summary>도메인이 아닌 DTO에서 검증을 하는 이유</summary>  

* DTO에서 요청 데이터를 받는 즉시 검증하는 이유는 다음과 같다:

  1. **입력 값의 기본 유효성 검사 수행**

    * 클라이언트가 보낸 데이터가 애초에 형식과 조건에 맞는지 빠르게 체크 가능
  2. **비즈니스 로직 실행 전 오류를 조기에 발견하여 비용 절감**

    * 도메인 계층까지 불필요한 로직 실행 없이 방어 가능
  3. **스프링 Validation 프레임워크와의 자연스러운 연동**

    * `@Valid` 애노테이션을 통한 자동 검증 지원

* 도메인에서 검증하지 않는 이유는

  * 도메인은 핵심 비즈니스 규칙에 집중하며, 외부 요청의 입력 형식 검증은 주로 `presentation` 계층에서 다루는 것이 역할 분리에 적합하다.
  * 도메인 내에 중복 검증 로직이 들어가면 코드가 복잡해지고 테스트도 어려워짐.

</details>  

<details> <summary>인프라스트럭처 계층은 다른 계층에 의존하면 안 된다?</summary>


인프라스트럭처 계층은 외부 시스템과의 통신(예: DB, 메시징, 파일시스템 등)을 담당하는 최하위 계층이다.

이 계층은 도메인, 애플리케이션, 래포지토리 같은 상위 계층에 의존하면 안 된다.

의존성 방향은 내부(도메인 등) → 외부(인프라스트럭처)이어야 한다.
즉, 인프라스트럭처는 독립적이어야 하며, 절대 상위 계층에 의존하지 않는다.
이렇게 하면 비즈니스 로직은 외부 기술 변화에 영향을 받지 않고 안정적으로 유지할 수 있다.

</details>

<details> <summary>왜 암호화인 단축 URL 키 생성 로직를 도메인에 넣어야 하는가?</summary>
단축 URL의 키 생성은 단순한 유틸성 로직이 아닌 비즈니스 규칙의 일부이다.

###  단순한 유틸성 로직(Utility Logic)

* **정의**: 비즈니스 맥락과 무관하게 어디서든 재사용 가능한 일반적인 기능
* **특징**:

  * 서비스 도메인과 독립적이다
  * 로직에 의미나 정책이 담겨 있지 않다
  * 여러 프로젝트에서 재사용될 수 있다
* **예시**:

  * 현재 시간 포맷팅 (`LocalDateTime → String`)
  * UUID 생성
  * Base64 인코딩/디코딩
  * 이메일 형식 검증

---

###  비즈니스 규칙(Business Rule)

* **정의**: 해당 도메인의 목적, 제약, 정책에 따라 작동해야 하는 규칙이나 행위
* **특징**:

  * 도메인의 의미를 반영하고 책임진다
  * 프로젝트의 요구사항에 따라 달라질 수 있다
  * 외부에서 자유롭게 재사용되지 않는다 (해당 서비스 고유)
* **예시**:

  * 단축 URL 키는 8자리이며 base56 문자만 사용한다
  * 같은 원본 URL로 요청이 들어와도 매번 다른 키를 생성한다
  * 단축 URL은 저장 후 리다이렉트 횟수를 누적 저장해야 한다

---

###  비교 예시

| 항목                          | 단순한 유틸성 로직                        | 비즈니스 규칙    |
| --------------------------- | --------------------------------- | ---------- |
| `UUID.randomUUID()`         | 어떤 상황에서도 쓰일 수 있음                  | X          |
| `generateShortenUrlKey()`   | 단순 랜덤 X, 정책적 제약 존재 (8자, base56 등) | O          |
| `@NotNull` 사용               | 값 존재 여부만 판단                       | O (DTO 수준) |
| `같은 원본 URL이라도 키는 매번 다르게 생성` | X                                 | O          |


예를 들어 키는 8자리여야 하며, 중복 없이 생성되어야 하고, 서비스 정책에 따라 사람이 읽기 쉬운 문자열로 구성되어야 한다.
이러한 규칙은 도메인의 핵심 역할인 비즈니스 의미를 반영한 데이터 생성 범주에 속한다.

즉, 키 생성 방식은 도메인 로직의 일부이므로, ShortenURL 엔티티 내부에서 직접 책임지는 것이 적절하다.
이를 통해 도메인의 응집도가 높아지고, 테스트도 명확하게 도메인 단위로 수행할 수 있다.

</details> <details> <summary>왜 base56을 사용하는가?</summary>
Base56은 일반적인 Base62 또는 Base64 인코딩에서 사람이 헷갈릴 수 있는 문자들을 제거한 문자 집합이다.
예를 들어 0, O, I, l, 1 등은 시각적으로 유사해 사용자가 실수할 가능성이 높다.

단축 URL은 사람들에게 공유되거나 직접 입력될 수도 있으므로,
사람이 읽고 입력하기 쉬우며 오류 가능성이 낮은 문자 집합을 사용하는 것이 중요하다.
Base56은 이러한 목적에 맞게 최적화된 문자 세트이므로, 사용자 경험을 향상시키는 데 도움이 된다.

</details>